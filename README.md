# 2018s-onion-team2 (Team Young-me)

## 1. Entity Function

### 1) Server
- 서버는 로그인된 클라이언트의 Github ID, IP Address, GPG Key ID 목록을 가지고 있음
- 서버는 새로운 클라이언트가 연결되면 클라이언트 목록을 업데이트함
- 서버는 주기적으로 client health check를 하여 클라이언트 목록을 업데이트함
- 서버는 클라이언트 목록이 업데이트 된 경우 클라이언트의 public key로 암호화된 클라이언트 목록을 각 클라이언트로 전송함

### 2) Client
- 서버의 health check에 응답함
- 로그인하는 경우에 경우 서버에 클라이언트의 등록을 요청함
- 로그아웃하는 경우에 서버에 클라이언트의 제거를 요청함
- 메시지와 최종 수신자까지의 경로를 각 거점이 되는 클라이언트의 public key로 순차적으로 암호화하여 송신함
- 메시지를 수신하면 복호화하여 자신이 최종 수신자인 경우 메시지를 화면에 표시하고 아닌 경우 다음 클라이언트로 전송함

## 2. Coummunication Protocol
### 1) Data Transfer
#### A. Plain Message Structure
```
0             1               2               3               4 byte
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 bit
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Flag (0x01) |             dst IP Address (4byte)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| dst IP Addr |             One Time key (4byte)              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| One Time Key|               Timestamp (4byte)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Timestamp  |            Github ID Length (4byte)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  GitID Len  |               Github ID (? byte)              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Github ID                          |
+                                                             +
                              ...
+                                                             +
|                                                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Message Length (4byte)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Message (?byte)                       |
+                                                             +
                             ....
+                                                             +
|                                                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- Flag (1 byte)
	- 0x00 : 송신 중인 암호화 데이터
	- 0x01 : 평문 데이터
	- 0x02 : 리스트 업데이트
	- 0x04 : 하트비트(UDP)
- dst IP Address (4 byte): 다음 목적지의 IP 주소, 평문일 경우 최종 목적지의 IP
- One Time Key (4 byte) : 송신자가 보낸 일회성 키를 의미하며, 수신자가 재응답시 해당 키를 포함하여 메시지를 송신하여야 한다.
- Timestamp (4 byte) : 송신을 기준으로 설정한 타임스탬프 값
- Github ID Length (4 byte) : 송신자의 Github ID의 길이를 나타내며, 최대 39byte를 초과할 수 없음
- Github ID (? < 40 byte) : 송신자의 Github ID, 최대 39바이트를 넘지 않는다.
- Message Length (4 byte) : 송신자가 보낸 메시지의 크기
- Message (? byte) : 송신자가 보낸 메시지

#### B. Encrypted Message Structure

```
0             1               2               3               4 byte
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 bit
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Flag (0x00) |             dst IP Address (4byte)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| dst IP Addr |          Encrypted Data Length (4byte)        |   
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Enc Data len|             Encrypted Data (?byte)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Encrypted Data (?byte)                     |
+                                                             +
                            ...
+                                                             +
|                                                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
- Flag (1 byte)
  - 0x00 : 송신 중인 암호화 데이터
  - 0x01 : 평문 데이터
  - 0x02 : 리스트 업데이트
  - 0x04 : 하트비트(UDP)
- dst IP Address (4 byte): 다음 목적지의 IP 주소, 평문일 경우 최종 목적지의 IP
- Encrypted Data Length (4 byte) : 암호화된 데이터의 길이
- Encrypted Data (? byte) : 암호화된 데이터

상기의 패킷 구조는 네트워크 서킷(Circuit)의 요소를 지나는 순서대로 다음 노드가 향해야할 IP와 함께 요소의 공개키(Public Key)로 암호화하여 전송된다.

수신 노드는 동일한 구조와 송신자가 송신한 One Time Key를 포함하여 다시 송신자에게 메시지를 전송한다. 다음은 각 노드에 번호가 있다고 가정하고, A에서 B로 3 -> 5 -> 4번 노드를 거쳐 전송되는 경우를 나타낸 것이다.

K<sub>3</sub> ( K<sub>5</sub> ( Flag, OTK, Git ID length, Timestamp, Git ID, Message Lenght, Message ),  IP<sub>4</sub> ), IP<sub>5</sub>

- K<sub>n</sub> : n번 요소의 공개키를 이용한 암호화
- OTK : One Time Key
- IP<sub>n</sub> : n번 요소의 IP

### 2) List Update
```
0             1               2               3               4 byte
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 bits
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Flag (0x02) |               Timestamp (4byte)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Timestamp  |  Mode (1byte) |     Publickey ID (8byte)      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Publickey ID (8byte)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Publickey ID         |      IP Address (4byte)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         IP Address          |    Github ID Length (4byte)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Github ID Length (4byte)  |     Github ID (? < 40byte)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Github ID                           |
+                                                             +
                             ...
+                                                             +
|                                                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- Flag (1 byte)
  - 0x00 : 송신 중인 암호화 데이터
  - 0x01 : 평문 데이터
  - 0x02 : 리스트 업데이트
  - 0x04 : 하트비트(UDP)
- Timestamp (4 byte) : 송신자의 송신 시간을 나타낸다.
- Mode (1 byte) : 업데이트 할 대상을 노드가 가지고 있는 리스트에서 처리할 방법을 나타낸다.
  - 0x00 : 추가
  - 0x01 : 삭제
- Publickey (8 byte) : 리스트에 업데이트할 대상의 공개키
- IP Address (4 byte) : 리스트에 업데이트할 대상의 IP 주소
- Git ID Length (4 byte) :리스트에 업데이트 할 대상의  Github ID의 길이를 나타내며, 최대 39byte를 초과할 수 없음
- Github ID (? byte) : 리스트에 업데이트할 대상의  Github ID를 나타내며, 최대 39byte를 넘지 않는다.

### 3) Heatbeat
 Heartbeat는 디렉토리 서버(Directory Server)에서 노드 리스트를 관리하기 위함으로써, 특정 노드의 생존 여부를 위해 사용한다.
```
0             1               2               3               4
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Flag (0x04) |              One Time key (4byte)             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| One Time Key|                Timestamp (4byte)              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Timestamp  | 
+-+-+-+-+-+-+-+

```

해당 Heartbeat 메시지를 수신한 노드는 동일한 One Time Key를 내포한 패킷을 재송신하여 자신이 살아있음을 디렉토리 서버에게 알려주어야 한다. 이때, 5초를 기준으로 하트비트가 오지않는다면 해당 서버에서 최대 3번 하트비트 패킷을 송신한다. 이때도 오지 않는다면, 서버를 죽은 것으로 간주하여 해당 서버의 등록 요청이 올 때까지 리스트에서 제거한다.

## Prototype 제작

### 소규모에서 규모를 늘려가며 개발을 한다. 그 모델은 다음과 같다. 
> 1차 : 클라이언트간 리스트를 미리 가지고 있다고 가정 하고, 클라이언트 들은 죽지 않는다고 가정한다. 이 때, 서버 없이 클라이언트간 통신이 가능한 모델을 제작한다.
> 2차 : 클라이언트는 서버에서 리스트를 받고, 이를 바탕으로 클라이언트 끼리 통신을 진행하는 모델을 제작한다. 이 때, 클라이언트 들은 죽지 않는다.
> 3차 : 클라이언트는 서버에서 리스트를 받고, 이를 바탕으로 클라이언트 끼리 통신을 진행하는 모델을 제작한다. 이 때, 클라이언트는 정상 종료을 위해 서버와 통신하며, 서버는 통신 후에 리스트를 업데이트 하여 다른 클라이언트에 분배한다.
> 4차 : 모든 클라이언트는 비정상종료가 될 수 있으며 이를 Heartbeat를 통해 리스트를 업데이트 시킬 수 있다. 이 리스트를 통해 클라이언트는 클라이언트 간의 통신을 진행 할 수 있다. (최종)
* 여기서 언급된 "통신은" Onion-routing을 통한 통신이다.

## Docker shell script 사용법

1. setdocker.sh 실행
setdocker.sh는 Docker의 네트워크 환경 및 Docker image를 build 해주는 스크립트 입니다.  

2. run.sh 실행
run.sh는 build된 image를 container로 만들어주고 실행시켜 주는 스크립트 입니다.
run.sh는 ./run.sh \[ container name \] \[ ssh port \] 로 실행시키시면 됩니다. 예시는 아래와 같습니다.
```
./run.sh do 50000 # onion_do 라는 컨테이너가 돌아가기 시작하며 50000번 포트는 컨테이너의 22번 포트로 포워딩 됩니다.  
```

3. (개발용) exec\_sh.sh 실행
exec\_sh.sh 는 개발 테스트 등에만 사용될 스크립트며, exec\_sh.sh \[ container name \]으로 실행시키시면 됩니다.
```
./exec_sh.sh onion_do # onion_do의 쉘이 뜹니다.
```


## Team Member 
-----
| Name        |Position| Role              |
|-------------|-------------------|-------------------|
| Suyoung Lee | Leader | Server & Client Coding     |
| Seokjoo Mun | Member | Protocol Design & Server Coding    |
| Taekjin Lee | Member | Server & Client Coding |
| Seunghan Hong | Member | Client Coding |
